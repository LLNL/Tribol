! wrapftribol_simple.F
! This file is generated by Shroud 0.12.1. Do not edit.
!
! Copyright (c) 2017-2023, Lawrence Livermore National Security, LLC and
! other Tribol Project Developers. See the top-level LICENSE file for details.
!
! SPDX-License-Identifier: (MIT).
!
!>
!! \file wrapftribol_simple.F
!! \brief Shroud generated wrapper for TRIBOL_SIMPLE library
!<
! splicer begin file_top
! splicer end file_top
module tribol_simple
    use iso_c_binding, only : C_INT, C_LONG, C_NULL_PTR, C_PTR, C_SIZE_T
    ! splicer begin module_use
    ! splicer end module_use
    implicit none

    ! splicer begin module_top
    ! splicer end module_top

    ! helper capsule_data_helper
    type, bind(C) :: SHROUD_capsule_data
        type(C_PTR) :: addr = C_NULL_PTR  ! address of C++ memory
        integer(C_INT) :: idtor = 0       ! index of destructor
    end type SHROUD_capsule_data

    ! helper array_context
    type, bind(C) :: TRIBOL_SIMPLE_SHROUD_array
        ! address of C++ memory
        type(SHROUD_capsule_data) :: cxx
        ! address of data in cxx
        type(C_PTR) :: base_addr = C_NULL_PTR
        ! type of element
        integer(C_INT) :: type
        ! bytes-per-item or character len of data in cxx
        integer(C_SIZE_T) :: elem_len = 0_C_SIZE_T
        ! size of data in cxx
        integer(C_SIZE_T) :: size = 0_C_SIZE_T
        ! number of dimensions
        integer(C_INT) :: rank = -1
        integer(C_LONG) :: shape(7) = 0
    end type TRIBOL_SIMPLE_SHROUD_array

    interface

        function c_initialize_0(dim) &
                result(SHT_rv) &
                bind(C, name="TRIBOL_SIMPLE_initialize_0")
            use iso_c_binding, only : C_INT
            implicit none
            integer(C_INT), value, intent(IN) :: dim
            integer(C_INT) :: SHT_rv
        end function c_initialize_0

        function c_initialize_1(dim, init_slic) &
                result(SHT_rv) &
                bind(C, name="TRIBOL_SIMPLE_initialize_1")
            use iso_c_binding, only : C_BOOL, C_INT
            implicit none
            integer(C_INT), value, intent(IN) :: dim
            logical(C_BOOL), value, intent(IN) :: init_slic
            integer(C_INT) :: SHT_rv
        end function c_initialize_1

        function c_finalize_0() &
                result(SHT_rv) &
                bind(C, name="TRIBOL_SIMPLE_finalize_0")
            use iso_c_binding, only : C_INT
            implicit none
            integer(C_INT) :: SHT_rv
        end function c_finalize_0

        function c_finalize_1(finalize_slic) &
                result(SHT_rv) &
                bind(C, name="TRIBOL_SIMPLE_finalize_1")
            use iso_c_binding, only : C_BOOL, C_INT
            implicit none
            logical(C_BOOL), value, intent(IN) :: finalize_slic
            integer(C_INT) :: SHT_rv
        end function c_finalize_1

        subroutine tribol_simple_setup_coupling(dim, contact_method, &
                master_numCells, master_lengthNodalData, &
                master_connectivity, master_x, master_y, master_z, &
                slave_numCells, slave_lengthNodalData, &
                slave_connectivity, slave_x, slave_y, slave_z, &
                area_frac, mortar_gaps, mortar_pressures) &
                bind(C, name="TRIBOL_SIMPLE_simple_coupling_setup")
            use iso_c_binding, only : C_DOUBLE, C_INT
            implicit none
            integer(C_INT), value, intent(IN) :: dim
            integer(C_INT), value, intent(IN) :: contact_method
            integer(C_INT), value, intent(IN) :: master_numCells
            integer(C_INT), value, intent(IN) :: master_lengthNodalData
            integer(C_INT), intent(IN) :: master_connectivity(*)
            real(C_DOUBLE), intent(IN) :: master_x(*)
            real(C_DOUBLE), intent(IN) :: master_y(*)
            real(C_DOUBLE), intent(IN) :: master_z(*)
            integer(C_INT), value, intent(IN) :: slave_numCells
            integer(C_INT), value, intent(IN) :: slave_lengthNodalData
            integer(C_INT), intent(IN) :: slave_connectivity(*)
            real(C_DOUBLE), intent(IN) :: slave_x(*)
            real(C_DOUBLE), intent(IN) :: slave_y(*)
            real(C_DOUBLE), intent(IN) :: slave_z(*)
            real(C_DOUBLE), value, intent(IN) :: area_frac
            real(C_DOUBLE), intent(IN) :: mortar_gaps(*)
            real(C_DOUBLE), intent(IN) :: mortar_pressures(*)
        end subroutine tribol_simple_setup_coupling

        function tribol_simple_update(dt) &
                result(SHT_rv) &
                bind(C, name="TRIBOL_SIMPLE_update")
            use iso_c_binding, only : C_DOUBLE, C_INT
            implicit none
            integer(C_INT) :: SHT_rv
            real(C_DOUBLE), value, intent(IN) :: dt
        end function tribol_simple_update

        function c_get_simple_coupling_csr(I, J, vals, n_offsets, &
                n_nonzeros) &
                result(SHT_rv) &
                bind(C, name="TRIBOL_SIMPLE_get_simple_coupling_csr")
            use iso_c_binding, only : C_INT, C_PTR
            implicit none
            type(C_PTR), intent(OUT) :: I
            type(C_PTR), intent(OUT) :: J
            type(C_PTR), intent(OUT) :: vals
            integer(C_INT), intent(OUT) :: n_offsets
            integer(C_INT), intent(OUT) :: n_nonzeros
            integer(C_INT) :: SHT_rv
        end function c_get_simple_coupling_csr

        function c_get_simple_coupling_csr_bufferify(DI, DJ, Dvals, &
                n_offsets, n_nonzeros) &
                result(SHT_rv) &
                bind(C, name="TRIBOL_SIMPLE_get_simple_coupling_csr_bufferify")
            use iso_c_binding, only : C_INT
            import :: TRIBOL_SIMPLE_SHROUD_array
            implicit none
            type(TRIBOL_SIMPLE_SHROUD_array), intent(INOUT) :: DI
            type(TRIBOL_SIMPLE_SHROUD_array), intent(INOUT) :: DJ
            type(TRIBOL_SIMPLE_SHROUD_array), intent(INOUT) :: Dvals
            integer(C_INT), intent(OUT) :: n_offsets
            integer(C_INT), intent(OUT) :: n_nonzeros
            integer(C_INT) :: SHT_rv
        end function c_get_simple_coupling_csr_bufferify

        ! splicer begin additional_interfaces
        ! splicer end additional_interfaces
    end interface

    interface tribol_simple_finalize
        module procedure tribol_simple_finalize_0
        module procedure tribol_simple_finalize_1
    end interface tribol_simple_finalize

    interface tribol_simple_initialize
        module procedure tribol_simple_initialize_0
        module procedure tribol_simple_initialize_1
    end interface tribol_simple_initialize

contains

    function tribol_simple_initialize_0(dim) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        integer(C_INT), value, intent(IN) :: dim
        integer(C_INT) :: SHT_rv
        ! splicer begin function.initialize_0
        SHT_rv = c_initialize_0(dim)
        ! splicer end function.initialize_0
    end function tribol_simple_initialize_0

    function tribol_simple_initialize_1(dim, init_slic) &
            result(SHT_rv)
        use iso_c_binding, only : C_BOOL, C_INT
        integer(C_INT), value, intent(IN) :: dim
        logical, value, intent(IN) :: init_slic
        integer(C_INT) :: SHT_rv
        ! splicer begin function.initialize_1
        logical(C_BOOL) SH_init_slic
        SH_init_slic = init_slic  ! coerce to C_BOOL
        SHT_rv = c_initialize_1(dim, SH_init_slic)
        ! splicer end function.initialize_1
    end function tribol_simple_initialize_1

    function tribol_simple_finalize_0() &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        integer(C_INT) :: SHT_rv
        ! splicer begin function.finalize_0
        SHT_rv = c_finalize_0()
        ! splicer end function.finalize_0
    end function tribol_simple_finalize_0

    function tribol_simple_finalize_1(finalize_slic) &
            result(SHT_rv)
        use iso_c_binding, only : C_BOOL, C_INT
        logical, value, intent(IN) :: finalize_slic
        integer(C_INT) :: SHT_rv
        ! splicer begin function.finalize_1
        logical(C_BOOL) SH_finalize_slic
        SH_finalize_slic = finalize_slic  ! coerce to C_BOOL
        SHT_rv = c_finalize_1(SH_finalize_slic)
        ! splicer end function.finalize_1
    end function tribol_simple_finalize_1

    function tribol_simple_get_coupling_CSR(I, J, vals) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, C_INT, c_f_pointer
        integer(C_INT), intent(OUT), pointer :: I(:)
        type(TRIBOL_SIMPLE_SHROUD_array) :: DI
        integer(C_INT), intent(OUT), pointer :: J(:)
        type(TRIBOL_SIMPLE_SHROUD_array) :: DJ
        real(C_DOUBLE), intent(OUT), pointer :: vals(:)
        type(TRIBOL_SIMPLE_SHROUD_array) :: Dvals
        integer(C_INT) :: n_offsets
        integer(C_INT) :: n_nonzeros
        integer(C_INT) :: SHT_rv
        ! splicer begin function.get_simple_coupling_csr
        SHT_rv = c_get_simple_coupling_csr_bufferify(DI, DJ, Dvals, &
            n_offsets, n_nonzeros)
        call c_f_pointer(DI%base_addr, I, DI%shape(1:1))
        call c_f_pointer(DJ%base_addr, J, DJ%shape(1:1))
        call c_f_pointer(Dvals%base_addr, vals, Dvals%shape(1:1))
        ! splicer end function.get_simple_coupling_csr
    end function tribol_simple_get_coupling_CSR

    ! splicer begin additional_functions
    ! splicer end additional_functions

end module tribol_simple
